<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji 관리</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background:#f5f5f5; }
        h1 { text-align:center; color:#333; }
        #emoji-list { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 20px; justify-content:center; }
        .emoji-item { position: relative; width: 100px; height: 100px; border: 1px solid #ccc; display: flex; align-items: center; justify-content: center; background:#fff; border-radius:8px; box-shadow:0 2px 5px rgba(0,0,0,0.1); }
        .emoji-item img { max-width: 100%; max-height: 100%; border-radius:4px; }
        .delete-btn { position: absolute; top: 5px; right: 5px; background: red; color: #fff; border: none; cursor: pointer; border-radius:4px; width:20px; height:20px; line-height:18px; font-size:12px; }

        #drop-zone { border: 2px dashed #aaa; padding: 30px; text-align: center; cursor: pointer; background:#fff; border-radius:8px; box-shadow:0 2px 5px rgba(0,0,0,0.1); transition:border-color 0.2s; }
        #drop-zone.hover { border-color: #333; }

        #canvas-popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; z-index: 1001; border: 1px solid #ccc; border-radius:10px; box-shadow:0 5px 15px rgba(0,0,0,0.3); max-width:90%; max-height:90%; overflow:auto; }
        #popup-overlay { display: none; position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.5); z-index:1000; }

        canvas { border: 1px solid #ccc; touch-action: none; display:block; margin:auto; background: transparent; }
        #canvas-controls { display:flex; justify-content: space-between; margin-top:10px; align-items:center; flex-wrap:wrap; }
        #canvas-controls button { padding:5px 10px; margin:5px; border:none; border-radius:5px; cursor:pointer; background:#007bff; color:#fff; }
        #canvas-controls input[type=color] { margin-left:10px; width:40px; height:30px; border:none; cursor:pointer; }
        #selection-info { font-size:14px; margin-left:10px; color:#555; }
    </style>
</head>
<body>

<h1>Emoji 관리</h1>
<div id="drop-zone">여기에 이미지 드래그 또는 클릭하여 업로드</div>
<div id="emoji-list"></div>

<div id="popup-overlay"></div>
<div id="canvas-popup">
    <canvas id="emoji-canvas" width="512" height="512"></canvas>
    <div id="canvas-controls">
        <div>
            <button id="rotate-btn">회전</button>
            <button id="flip-btn">좌우 반전</button>
            <input type="color" id="bg-color-picker" title="배경색 선택">
            <span id="selection-info"></span>
        </div>
        <div>
            <button id="confirm-btn">확인</button>
            <button id="cancel-btn">취소</button>
        </div>
    </div>
</div>

<input type="file" id="file-input" accept="image/*" style="display:none;">

<script>
    const emojiList = document.getElementById('emoji-list');
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const popup = document.getElementById('canvas-popup');
    const overlay = document.getElementById('popup-overlay');
    const canvas = document.getElementById('emoji-canvas');
    const ctx = canvas.getContext('2d');
    const confirmBtn = document.getElementById('confirm-btn');
    const cancelBtn = document.getElementById('cancel-btn');
    const rotateBtn = document.getElementById('rotate-btn');
    const flipBtn = document.getElementById('flip-btn');
    const bgColorPicker = document.getElementById('bg-color-picker');
    const selectionInfo = document.getElementById('selection-info');

    let uploadedFile = null;
    let img = new Image();
    let rotation = 0;
    let flipped = false;
    let bgColor = 'transparent';

    // 선택 영역
    let selection = { x:0, y:0, size:256 };
    let dragging = false, resizing=false, currentHandle=null, startPos={x:0,y:0};

    // --- Emoji 목록 ---
    function fetchEmojiList(){
        fetch('/file/emoji')
            .then(res => res.json())
            .then(data => {
                const list = Array.isArray(data) ? data : (data?.body || []);
                emojiList.innerHTML='';
                list.forEach(item=>{
                    const div=document.createElement('div');
                    div.className='emoji-item';
                    const image=document.createElement('img');
                    image.src=item.directory?`/file/emoji/resource/${encodeURIComponent(item.directory)}`:'';
                    div.appendChild(image);
                    const delBtn=document.createElement('button');
                    delBtn.textContent='X';
                    delBtn.className='delete-btn';
                    delBtn.onclick=()=>deleteEmoji(item.id);
                    div.appendChild(delBtn);
                    emojiList.appendChild(div);
                });
            }).catch(err=>console.error(err));
    }

    function deleteEmoji(id){
        fetch(`/admin/emoji/${id}`, {method:'DELETE'})
            .then(res=>res.json())
            .then(data=>{ if(data?.success) fetchEmojiList(); else alert(data?.message||'삭제 실패'); })
            .catch(err=>{ console.error(err); alert('삭제 실패 (서버 오류)'); });
    }

    // --- 드래그앤드롭 ---
    dropZone.addEventListener('click',()=>fileInput.click());
    dropZone.addEventListener('dragover',e=>{e.preventDefault(); dropZone.classList.add('hover');});
    dropZone.addEventListener('dragleave',e=>{e.preventDefault(); dropZone.classList.remove('hover');});
    dropZone.addEventListener('drop',e=>{e.preventDefault(); dropZone.classList.remove('hover'); handleFile(e.dataTransfer.files[0]);});
    fileInput.addEventListener('change',e=>handleFile(e.target.files[0]));

    function handleFile(file){
        if(!file) return;
        const imgURL=URL.createObjectURL(file);
        img.onload=()=>{
            uploadedFile=file;
            rotation=0; flipped=false;
            selection={x:0,y:0,size:Math.max(256,Math.min(img.width,img.height))};
            drawCanvas();
            overlay.style.display='block';
            popup.style.display='block';
        };
        img.src=imgURL;
    }

    // --- 캔버스 그리기 ---
    function drawCanvas(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle=bgColor; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.save();
        ctx.translate(canvas.width/2,canvas.height/2);
        if(flipped) ctx.scale(-1,1);
        ctx.rotate(rotation*Math.PI/180);
        ctx.drawImage(img, -canvas.width/2, -canvas.height/2, canvas.width, canvas.height);
        ctx.restore();

        // 선택 영역
        ctx.strokeStyle='red';
        ctx.setLineDash([5,3]);
        ctx.strokeRect(selection.x,selection.y,selection.size,selection.size);
        ctx.setLineDash([]);
        selectionInfo.textContent=`x:${selection.x} y:${selection.y} size:${selection.size}`;
    }

    // --- 마우스/터치 이벤트 ---
    canvas.addEventListener('mousedown',startMouse);
    canvas.addEventListener('mousemove',moveMouse);
    canvas.addEventListener('mouseup',endMouse);
    canvas.addEventListener('mouseleave',endMouse);
    canvas.addEventListener('touchstart',e=>{const t=e.touches[0]; startMouse({clientX:t.clientX,clientY:t.clientY}); e.preventDefault();});
    canvas.addEventListener('touchmove',e=>{const t=e.touches[0]; moveMouse({clientX:t.clientX,clientY:t.clientY}); e.preventDefault();});
    canvas.addEventListener('touchend',e=>{endMouse(); e.preventDefault();});

    function startMouse(e){
        const rect=canvas.getBoundingClientRect();
        const mx=e.clientX-rect.left, my=e.clientY-rect.top;
        const handles=[
            {name:'nw',x:selection.x,y:selection.y},
            {name:'ne',x:selection.x+selection.size,y:selection.y},
            {name:'sw',x:selection.x,y:selection.y+selection.size},
            {name:'se',x:selection.x+selection.size,y:selection.y+selection.size}
        ];
        currentHandle=null;
        for(let h of handles){
            if(Math.abs(mx-h.x)<=10 && Math.abs(my-h.y)<=10){
                resizing=true; currentHandle=h.name; return;
            }
        }
        if(mx>=selection.x && mx<=selection.x+selection.size && my>=selection.y && my<=selection.y+selection.size){
            dragging=true; startPos={x:mx-selection.x,y:my-selection.y};
        }
    }

    function moveMouse(e){
        const rect=canvas.getBoundingClientRect();
        const mx=e.clientX-rect.left, my=e.clientY-rect.top;
        if(dragging){ selection.x=Math.max(0,Math.min(mx-startPos.x,canvas.width-selection.size)); selection.y=Math.max(0,Math.min(my-startPos.y,canvas.height-selection.size)); drawCanvas();}
        else if(resizing && currentHandle){
            let newX=selection.x,newY=selection.y,newSize=selection.size;
            switch(currentHandle){
                case 'se': newSize=Math.max(256,Math.min(mx-selection.x,my-selection.y)); break;
                case 'sw': newSize=Math.max(256,Math.min(selection.x+selection.size-mx,my-selection.y)); newX=selection.x+selection.size-newSize; break;
                case 'ne': newSize=Math.max(256,Math.min(mx-selection.x,selection.y+selection.size-my)); newY=selection.y+selection.size-newSize; break;
                case 'nw': newSize=Math.max(256,Math.min(selection.x+selection.size-mx,selection.y+selection.size-my)); newX=selection.x+selection.size-newSize; newY=selection.y+selection.size-newSize; break;
            }
            if(newX<0) newX=0; if(newY<0) newY=0;
            if(newX+newSize>canvas.width) newSize=canvas.width-newX;
            if(newY+newSize>canvas.height) newSize=canvas.height-newY;
            selection={x:newX,y:newY,size:newSize};
            drawCanvas();
        }
    }
    function endMouse(){ dragging=resizing=false; currentHandle=null; }

    // --- 팝업 닫기 ---
    function closePopup(){ overlay.style.display='none'; popup.style.display='none'; fileInput.value=''; uploadedFile=null; }
    cancelBtn.addEventListener('click',closePopup);
    overlay.addEventListener('click',closePopup);

    // --- 회전/반전 ---
    rotateBtn.addEventListener('click',()=>{ rotation=(rotation+90)%360; drawCanvas(); });
    flipBtn.addEventListener('click',()=>{ flipped=!flipped; drawCanvas(); });

    // --- 배경색 ---
    bgColorPicker.addEventListener('change',e=>{ bgColor=e.target.value; drawCanvas(); });

    // --- 업로드 ---
    confirmBtn.addEventListener('click',()=>{
        if(!uploadedFile) return;
        const tmpCanvas=document.createElement('canvas');
        tmpCanvas.width=selection.size; tmpCanvas.height=selection.size;
        const tmpCtx=tmpCanvas.getContext('2d');

        // 선택 영역 좌표 비율 적용
        const scaleX=img.width/canvas.width, scaleY=img.height/canvas.height;
        tmpCtx.fillStyle=bgColor; tmpCtx.fillRect(0,0,tmpCanvas.width,tmpCanvas.height);
        tmpCtx.save();
        tmpCtx.translate(tmpCanvas.width/2,tmpCanvas.height/2);
        if(flipped) tmpCtx.scale(-1,1);
        tmpCtx.rotate(rotation*Math.PI/180);
        tmpCtx.drawImage(img,
            selection.x*scaleX - canvas.width/2,
            selection.y*scaleY - canvas.height/2,
            selection.size*scaleX,
            selection.size*scaleY,
            -tmpCanvas.width/2,
            -tmpCanvas.height/2,
            tmpCanvas.width,
            tmpCanvas.height
        );
        tmpCtx.restore();

        tmpCanvas.toBlob(blob=>{
            const formData=new FormData();
            formData.append('file',blob,uploadedFile.name.replace(/\.[^/.]+$/,".png"));
            fetch(`/admin/emoji/${uploadedFile.name.replace(/\.[^/.]+$/,".png")}`,{method:'POST',body:formData})
                .then(res=>res.json())
                .then(data=>{ if(data?.success){ closePopup(); fetchEmojiList(); } else alert('업로드 실패'); })
                .catch(err=>console.error(err));
        },'image/png');
    });

    fetchEmojiList();
</script>
</body>
</html>
