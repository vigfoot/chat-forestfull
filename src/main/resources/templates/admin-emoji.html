<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji 관리</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #emoji-list { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 20px; }
        .emoji-item { position: relative; width: 100px; height: 100px; border: 1px solid #ccc; display: flex; align-items: center; justify-content: center; }
        .emoji-item img { max-width: 100%; max-height: 100%; }
        .delete-btn { position: absolute; top: 0; right: 0; background: red; color: #fff; border: none; cursor: pointer; }

        #drop-zone { border: 2px dashed #aaa; padding: 20px; text-align: center; cursor: pointer; }
        #drop-zone.hover { border-color: #333; }

        #canvas-popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; z-index: 1001; border: 1px solid #ccc; }
        #popup-overlay { display: none; position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.5); z-index:1000; }
        canvas { border: 1px solid #ccc; touch-action: none; }
    </style>
</head>
<body>

<h1>Emoji 관리</h1>

<div id="drop-zone">여기에 이미지 드래그 또는 클릭하여 업로드</div>
<div id="emoji-list"></div>

<div id="popup-overlay"></div>
<div id="canvas-popup">
    <canvas id="emoji-canvas" width="512" height="512"></canvas>
    <div style="margin-top:10px;">
        <button id="confirm-btn">확인</button>
        <button id="cancel-btn">취소</button>
    </div>
</div>

<input type="file" id="file-input" accept="image/*" style="display:none;">

<script>
    const emojiList = document.getElementById('emoji-list');
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const popup = document.getElementById('canvas-popup');
    const overlay = document.getElementById('popup-overlay');
    const canvas = document.getElementById('emoji-canvas');
    const ctx = canvas.getContext('2d');
    const confirmBtn = document.getElementById('confirm-btn');
    const cancelBtn = document.getElementById('cancel-btn');

    let uploadedFile = null;
    let img = new Image();

    // 선택 영역
    let selection = { x:0, y:0, size:256 };
    let dragging = false;
    let resizing = false;
    let currentHandle = null;
    let startPos = {x:0, y:0};

    // --- Emoji 목록 ---
    function fetchEmojiList() {
        fetch('/file/emoji')
            .then(res => res.json())
            .then(data => {
                const list = Array.isArray(data) ? data : (data?.body || []);
                emojiList.innerHTML = '';
                list.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'emoji-item';
                    const image = document.createElement('img');
                    image.src = item.directory ? `/file/emoji/resource/${encodeURIComponent(item.directory)}` : '';
                    div.appendChild(image);

                    const delBtn = document.createElement('button');
                    delBtn.textContent = 'X';
                    delBtn.className = 'delete-btn';
                    delBtn.onclick = () => deleteEmoji(item.id);
                    div.appendChild(delBtn);

                    emojiList.appendChild(div);
                });
            })
            .catch(err => console.error(err));
    }

    function deleteEmoji(id) {
        fetch(`/admin/emoji/${id}`, { method: 'DELETE' })
            .then(res => res.json())
            .then(data => {
                if(data?.success) fetchEmojiList();
                else alert(data?.message || '삭제 실패');
            })
            .catch(err => { console.error(err); alert('삭제 실패 (서버 오류)'); });
    }

    // --- 드래그앤드롭 ---
    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('hover'); });
    dropZone.addEventListener('dragleave', e => { e.preventDefault(); dropZone.classList.remove('hover'); });
    dropZone.addEventListener('drop', e => { e.preventDefault(); dropZone.classList.remove('hover'); handleFile(e.dataTransfer.files[0]); });
    fileInput.addEventListener('change', e => handleFile(e.target.files[0]));

    function handleFile(file) {
        if(!file) return;
        const imgURL = URL.createObjectURL(file);
        img.onload = () => {
            if(img.width < 256 || img.height < 256) { alert('이미지 최소 사이즈 256x256 이상이어야 합니다.'); return; }
            uploadedFile = file;
            selection = { x:0, y:0, size:256 };
            drawCanvas();
            overlay.style.display = 'block';
            popup.style.display = 'block';
        };
        img.src = imgURL;
    }

    // --- 캔버스 그리기 ---
    function drawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        // UI용 점선 사각형
        ctx.strokeStyle = 'red';
        ctx.setLineDash([5,3]);
        ctx.strokeRect(selection.x, selection.y, selection.size, selection.size);
        ctx.setLineDash([]);
    }

    // --- 마우스 이벤트 ---
    canvas.addEventListener('mousedown', startMouse);
    canvas.addEventListener('mousemove', moveMouse);
    canvas.addEventListener('mouseup', endMouse);
    canvas.addEventListener('mouseleave', endMouse);

    canvas.addEventListener('touchstart', e => { const t=e.touches[0]; startMouse({clientX:t.clientX, clientY:t.clientY}); e.preventDefault(); });
    canvas.addEventListener('touchmove', e => { const t=e.touches[0]; moveMouse({clientX:t.clientX, clientY:t.clientY}); e.preventDefault(); });
    canvas.addEventListener('touchend', e => { endMouse(); e.preventDefault(); });

    function startMouse(e) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const handles = [
            { name:'nw', x: selection.x, y: selection.y },
            { name:'ne', x: selection.x + selection.size, y: selection.y },
            { name:'sw', x: selection.x, y: selection.y + selection.size },
            { name:'se', x: selection.x + selection.size, y: selection.y + selection.size }
        ];
        currentHandle = null;
        for(let h of handles){
            if(Math.abs(mx - h.x) <=10 && Math.abs(my - h.y) <=10) {
                resizing = true;
                currentHandle = h.name;
                return;
            }
        }
        if(mx >= selection.x && mx <= selection.x + selection.size && my >= selection.y && my <= selection.y + selection.size){
            dragging = true;
            startPos = { x: mx - selection.x, y: my - selection.y };
        }
    }

    function moveMouse(e) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        if(dragging){
            selection.x = Math.max(0, Math.min(mx - startPos.x, canvas.width - selection.size));
            selection.y = Math.max(0, Math.min(my - startPos.y, canvas.height - selection.size));
            drawCanvas();
        } else if(resizing && currentHandle){
            let newX = selection.x, newY = selection.y, newSize = selection.size;
            switch(currentHandle){
                case 'se': newSize = Math.max(256, Math.min(mx - selection.x, my - selection.y)); break;
                case 'sw': newSize = Math.max(256, Math.min(selection.x + selection.size - mx, my - selection.y)); newX = selection.x + selection.size - newSize; break;
                case 'ne': newSize = Math.max(256, Math.min(mx - selection.x, selection.y + selection.size - my)); newY = selection.y + selection.size - newSize; break;
                case 'nw': newSize = Math.max(256, Math.min(selection.x + selection.size - mx, selection.y + selection.size - my)); newX = selection.x + selection.size - newSize; newY = selection.y + selection.size - newSize; break;
            }
            if(newX<0) newX=0;
            if(newY<0) newY=0;
            if(newX+newSize>canvas.width) newSize=canvas.width - newX;
            if(newY+newSize>canvas.height) newSize=canvas.height - newY;
            selection={x:newX,y:newY,size:newSize};
            drawCanvas();
        }
    }

    function endMouse(){ dragging=false; resizing=false; currentHandle=null; }

    // --- 팝업 닫기 ---
    function closePopup(){ overlay.style.display='none'; popup.style.display='none'; fileInput.value=''; uploadedFile=null; }
    cancelBtn.addEventListener('click', closePopup);
    overlay.addEventListener('click', closePopup);

    // --- 업로드 ---
    confirmBtn.addEventListener('click', ()=>{
        if(!uploadedFile) return;

        const tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = selection.size;
        tmpCanvas.height = selection.size;
        const tmpCtx = tmpCanvas.getContext('2d');

        const scaleX = img.width / canvas.width;
        const scaleY = img.height / canvas.height;

        tmpCtx.drawImage(img,
            selection.x * scaleX,
            selection.y * scaleY,
            selection.size * scaleX,
            selection.size * scaleY,
            0, 0,
            selection.size,
            selection.size
        );

        tmpCanvas.toBlob(blob => {
            const formData = new FormData();
            formData.append('file', blob, uploadedFile.name);
            fetch(`/admin/emoji/${uploadedFile.name}`, { method:'POST', body: formData })
                .then(res=>res.json())
                .then(data=>{
                    if(data?.success){ closePopup(); fetchEmojiList(); }
                    else alert('업로드 실패');
                }).catch(err=>console.error(err));
        }, 'image/png');
    });

    fetchEmojiList();
</script>

</body>
</html>