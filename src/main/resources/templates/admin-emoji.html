<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji 관리</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #f4f4f4; }
        h1 { text-align: center; }
        #emoji-list { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 20px; justify-content: center; }
        .emoji-item { position: relative; width: 100px; height: 100px; border-radius: 8px; background: #fff; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.2);}
        .emoji-item img { max-width: 90%; max-height: 90%; border-radius: 4px; }
        .delete-btn { position: absolute; top: 2px; right: 2px; background: red; color: #fff; border: none; cursor: pointer; border-radius: 50%; width:20px;height:20px; font-size:12px; }

        #drop-zone { border: 2px dashed #aaa; padding: 20px; text-align: center; cursor: pointer; border-radius: 8px; background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1);}
        #drop-zone.hover { border-color: #333; }

        #canvas-popup { display: none; position: fixed; top:50%; left:50%; transform: translate(-50%, -50%); background: #fff; padding: 15px; z-index:1001; border-radius: 8px; box-shadow:0 5px 15px rgba(0,0,0,0.3); }
        #popup-overlay { display:none; position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.5); z-index:1000; }

        canvas { border: 1px solid #ccc; touch-action: none; display:block; margin:0 auto; }
        #controls { display:flex; justify-content: space-between; margin-top:10px; }
        #controls > * { margin-right: 5px; }

        .handle { width: 14px; height: 14px; background: #ff5722; position:absolute; border-radius:50%; box-shadow:0 0 3px rgba(0,0,0,0.3); cursor: pointer; }
        #info { text-align:center; margin-top:5px; font-size:14px; }
    </style>
</head>
<body>

<h1>Emoji 관리</h1>

<div id="drop-zone">이미지 드래그 또는 클릭</div>
<div id="emoji-list"></div>

<div id="popup-overlay"></div>
<div id="canvas-popup">
    <canvas id="emoji-canvas" width="512" height="512"></canvas>
    <div id="info">선택 영역: X=0, Y=0, 크기=256</div>
    <div style="margin-top:10px;">
        <label>배경색: <input type="color" id="bg-color" value="#ffffff"></label>
        <button id="rotate-btn">회전</button>
        <button id="flip-btn">좌우 반전</button>
        <button id="reset-filter">필터 초기화</button>
        <label>밝기: <input type="range" id="brightness" min="0" max="200" value="100"></label>
        <label>대비: <input type="range" id="contrast" min="0" max="200" value="100"></label>
        <label>채도: <input type="range" id="saturate" min="0" max="200" value="100"></label>
    </div>
    <div id="controls">
        <button id="confirm-btn">확인</button>
        <button id="cancel-btn">취소</button>
    </div>
</div>

<input type="file" id="file-input" accept="image/*" style="display:none;">

<script>
    const emojiList = document.getElementById('emoji-list');
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const popup = document.getElementById('canvas-popup');
    const overlay = document.getElementById('popup-overlay');
    const canvas = document.getElementById('emoji-canvas');
    const ctx = canvas.getContext('2d');
    const confirmBtn = document.getElementById('confirm-btn');
    const cancelBtn = document.getElementById('cancel-btn');
    const bgColorInput = document.getElementById('bg-color');
    const rotateBtn = document.getElementById('rotate-btn');
    const flipBtn = document.getElementById('flip-btn');
    const brightnessInput = document.getElementById('brightness');
    const contrastInput = document.getElementById('contrast');
    const saturateInput = document.getElementById('saturate');
    const resetFilterBtn = document.getElementById('reset-filter');
    const info = document.getElementById('info');

    let uploadedFile = null;
    let img = new Image();

    // 선택 영역
    let selection = {x:0, y:0, size:256};
    let dragging=false, resizing=false, currentHandle=null, startPos={x:0,y:0};

    // 회전/반전/필터
    let rotation = 0; // 0,90,180,270
    let flipped = false;
    let brightness = 100, contrast =100, saturate=100;

    // --- Emoji 목록 ---
    function fetchEmojiList(){
        fetch('/file/emoji')
            .then(res=>res.json())
            .then(data=>{
                const list = Array.isArray(data) ? data : (data?.body || []);
                emojiList.innerHTML='';
                list.forEach(item=>{
                    const div=document.createElement('div'); div.className='emoji-item';
                    const image=document.createElement('img');
                    image.src = item.directory ? `/file/emoji/resource/${encodeURIComponent(item.directory)}` : '';
                    div.appendChild(image);

                    const delBtn=document.createElement('button');
                    delBtn.textContent='X'; delBtn.className='delete-btn';
                    delBtn.onclick = ()=>deleteEmoji(item.id);
                    div.appendChild(delBtn);

                    emojiList.appendChild(div);
                });
            }).catch(err=>console.error(err));
    }
    function deleteEmoji(id){
        fetch(`/admin/emoji/${id}`,{method:'DELETE'})
            .then(res=>res.json())
            .then(data=>{ if(data?.success) fetchEmojiList(); else alert('삭제 실패'); })
            .catch(err=>{ console.error(err); alert('삭제 실패'); });
    }

    // --- 드래그앤드롭 ---
    dropZone.addEventListener('click',()=>fileInput.click());
    dropZone.addEventListener('dragover', e=>{ e.preventDefault(); dropZone.classList.add('hover'); });
    dropZone.addEventListener('dragleave', e=>{ e.preventDefault(); dropZone.classList.remove('hover'); });
    dropZone.addEventListener('drop', e=>{ e.preventDefault(); dropZone.classList.remove('hover'); handleFile(e.dataTransfer.files[0]); });
    fileInput.addEventListener('change', e=>handleFile(e.target.files[0]));

    function handleFile(file){
        if(!file) return;
        const url=URL.createObjectURL(file);
        img.onload = ()=>{
            // 최소 256x256 이상이면 OK, 미만이면 확대
            if(img.width<256 || img.height<256){
                selection.size = 256;
            } else {
                selection.size = Math.min(256,img.width,img.height);
            }
            uploadedFile=file;
            drawCanvas();
            overlay.style.display='block';
            popup.style.display='block';
        }
        img.src=url;
    }

    // --- 캔버스 그리기 ---
    function drawCanvas(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.save();
        // 배경색
        ctx.fillStyle=bgColorInput.value; ctx.fillRect(0,0,canvas.width,canvas.height);
        // 필터
        ctx.filter = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturate}%)`;
        ctx.translate(canvas.width/2, canvas.height/2);
        if(flipped) ctx.scale(-1,1);
        ctx.rotate(rotation*Math.PI/180);
        ctx.drawImage(img, -canvas.width/2, -canvas.height/2, canvas.width, canvas.height);
        ctx.restore();

        // 점선 선택 영역
        ctx.strokeStyle='red'; ctx.setLineDash([5,3]);
        ctx.strokeRect(selection.x, selection.y, selection.size, selection.size);
        ctx.setLineDash([]);
        info.textContent=`X=${Math.round(selection.x)}, Y=${Math.round(selection.y)}, 크기=${Math.round(selection.size)}`;
    }

    // --- 마우스 / 터치 이벤트 ---
    canvas.addEventListener('mousedown', startMouse);
    canvas.addEventListener('mousemove', moveMouse);
    canvas.addEventListener('mouseup', endMouse);
    canvas.addEventListener('mouseleave', endMouse);

    canvas.addEventListener('touchstart', e=>{ const t=e.touches[0]; startMouse({clientX:t.clientX, clientY:t.clientY}); e.preventDefault(); });
    canvas.addEventListener('touchmove', e=>{ const t=e.touches[0]; moveMouse({clientX:t.clientX, clientY:t.clientY}); e.preventDefault(); });
    canvas.addEventListener('touchend', e=>{ endMouse(); e.preventDefault(); });

    function startMouse(e){
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX-rect.left;
        const my = e.clientY-rect.top;
        const handles = [
            {name:'nw', x:selection.x, y:selection.y},
            {name:'ne', x:selection.x+selection.size, y:selection.y},
            {name:'sw', x:selection.x, y:selection.y+selection.size},
            {name:'se', x:selection.x+selection.size, y:selection.y+selection.size}
        ];
        currentHandle=null;
        for(let h of handles){
            if(Math.abs(mx-h.x)<=10 && Math.abs(my-h.y)<=10){resizing=true; currentHandle=h.name; return;}
        }
        if(mx>=selection.x && mx<=selection.x+selection.size && my>=selection.y && my<=selection.y+selection.size){
            dragging=true;
            startPos={x:mx-selection.x, y:my-selection.y};
        }
    }
    function moveMouse(e){
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX-rect.left;
        const my = e.clientY-rect.top;
        if(dragging){ selection.x=Math.max(0,Math.min(mx-startPos.x,canvas.width-selection.size)); selection.y=Math.max(0,Math.min(my-startPos.y,canvas.height-selection.size)); drawCanvas(); }
        else if(resizing && currentHandle){
            let newX=selection.x, newY=selection.y, newSize=selection.size;
            switch(currentHandle){
                case 'se': newSize = Math.max(256, Math.min(mx-selection.x, my-selection.y)); break;
                case 'sw': newSize = Math.max(256, Math.min(selection.x+selection.size-mx, my-selection.y)); newX=selection.x+selection.size-newSize; break;
                case 'ne': newSize = Math.max(256, Math.min(mx-selection.x, selection.y+selection.size-my)); newY=selection.y+selection.size-newSize; break;
                case 'nw': newSize = Math.max(256, Math.min(selection.x+selection.size-mx, selection.y+selection.size-my)); newX=selection.x+selection.size-newSize; newY=selection.y+selection.size-newSize; break;
            }
            if(newX<0)newX=0; if(newY<0)newY=0;
            if(newX+newSize>canvas.width)newSize=canvas.width-newX;
            if(newY+newSize>canvas.height)newSize=canvas.height-newY;
            selection={x:newX,y:newY,size:newSize}; drawCanvas();
        }
    }
    function endMouse(){ dragging=false; resizing=false; currentHandle=null; }

    // --- 팝업 닫기 ---
    function closePopup(){ overlay.style.display='none'; popup.style.display='none'; fileInput.value=''; uploadedFile=null; rotation=0; flipped=false; brightness=100; contrast=100; saturate=100; drawCanvas();}
    cancelBtn.addEventListener('click', closePopup);
    overlay.addEventListener('click', closePopup);

    // --- 회전 / 반전 / 필터 ---
    rotateBtn.addEventListener('click', ()=>{ rotation=(rotation+90)%360; drawCanvas(); });
    flipBtn.addEventListener('click', ()=>{ flipped=!flipped; drawCanvas(); });
    brightnessInput.addEventListener('input', e=>{ brightness=e.target.value; drawCanvas(); });
    contrastInput.addEventListener('input', e=>{ contrast=e.target.value; drawCanvas(); });
    saturateInput.addEventListener('input', e=>{ saturate=e.target.value; drawCanvas(); });
    resetFilterBtn.addEventListener('click', ()=>{ brightness=100; contrast=100; saturate=100; drawCanvas(); });

    // --- 업로드 ---
    confirmBtn.addEventListener('click', ()=>{
        if(!uploadedFile) return;
        const tmpCanvas=document.createElement('canvas');
        tmpCanvas.width=selection.size; tmpCanvas.height=selection.size;
        const tmpCtx=tmpCanvas.getContext('2d');

        tmpCtx.fillStyle=bgColorInput.value; tmpCtx.fillRect(0,0,tmpCanvas.width,tmpCanvas.height);
        tmpCtx.filter = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturate}%)`;
        tmpCtx.save();
        tmpCtx.translate(tmpCanvas.width/2, tmpCanvas.height/2);
        if(flipped) tmpCtx.scale(-1,1);
        tmpCtx.rotate(rotation*Math.PI/180);

        // 선택 영역 좌표 변환
        const scaleX = img.width / canvas.width;
        const scaleY = img.height / canvas.height;
        const sx = selection.x*scaleX;
        const sy = selection.y*scaleY;
        const sWidth = selection.size*scaleX;
        const sHeight = selection.size*scaleY;

        tmpCtx.drawImage(img, sx, sy, sWidth, sHeight, -tmpCanvas.width/2, -tmpCanvas.height/2, tmpCanvas.width, tmpCanvas.height);
        tmpCtx.restore();

        tmpCanvas.toBlob(blob=>{
            const formData = new FormData();
            formData.append('file', blob, uploadedFile.name.replace(/\..+$/,'')+'.png'); // PNG 강제
            fetch(`/admin/emoji/${uploadedFile.name}`,{method:'POST', body:formData})
                .then(res=>res.json())
                .then(data=>{ if(data?.success){ closePopup(); fetchEmojiList(); } else alert('업로드 실패'); })
                .catch(err=>console.error(err));
        }, 'image/png');
    });

    fetchEmojiList();
</script>

</body>
</html>
